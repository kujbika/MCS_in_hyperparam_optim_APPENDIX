estimator(y, 6)
y = arima.sim(n = 1000, list(ar=c(phi)), sd=sqrt(sigma2), mean=alpha)
estimator(y, 3)
estimator(y, 6)
y = arima.sim(n = 1000, list(ar=c(phi)), sd=sqrt(sigma2), mean=alpha)
estimator(y, 3)
estimator(y, 6)
y = arima.sim(n = 1000, list(ar=c(phi)), sd=sqrt(sigma2), mean=alpha)
estimator(y, 3)
estimator(y, 6)
y = arima.sim(n = 1000, list(ar=c(phi)), sd=sqrt(sigma2), mean=alpha)
estimator(y, 3)
estimator(y, 6)
y = arima.sim(n = 1000, list(ar=c(phi)), sd=sqrt(sigma2), mean=alpha)
estimator(y, 3)
estimator(y, 6)
y = arima.sim(n = 1000, list(ar=c(phi)), sd=sqrt(sigma2), mean=alpha)
estimator(y, 3)
estimator(y, 6)
y = arima.sim(n = 1000, list(ar=c(phi)), sd=sqrt(sigma2), mean=alpha)
estimator(y, 3)
estimator(y, 6)
y = arima.sim(n = 1000, list(ar=c(phi)), sd=sqrt(sigma2), mean=alpha)
estimator(y, 3)
estimator(y, 6)
y = arima.sim(n = 1000, list(ar=c(phi)), sd=sqrt(sigma2), mean=alpha)
estimator(y, 3)
estimator(y, 6)
y = arima.sim(n = 1000, list(ar=c(phi)), sd=sqrt(sigma2), mean=alpha)
estimator(y, 3)
estimator(y, 6)
y = arima.sim(n = 1000, list(ar=c(phi)), sd=sqrt(sigma2), mean=alpha)
estimator(y, 3)
estimator(y, 6)
y = arima.sim(n = 1000, list(ar=c(phi)), sd=sqrt(sigma2), mean=alpha)
estimator(y, 3)
estimator(y, 6)
y = arima.sim(n = 1000, list(ar=c(phi)), sd=sqrt(sigma2), mean=alpha)
estimator(y, 3)
estimator(y, 6)
y = arima.sim(n = 1000, list(ar=c(phi)), sd=sqrt(sigma2), mean=alpha)
estimator(y, 3)
estimator(y, 6)
y = arima.sim(n = 1000, list(ar=c(phi)), sd=sqrt(sigma2), mean=alpha)
estimator(y, 3)
estimator(y, 6)
y = arima.sim(n = 1000, list(ar=c(phi)), sd=sqrt(sigma2), mean=alpha)
estimator(y, 3)
estimator(y, 6)
y = arima.sim(n = 1000, list(ar=c(phi)), sd=sqrt(sigma2), mean=alpha)
estimator(y, 3)
estimator(y, 6)
y = arima.sim(n = 1000, list(ar=c(phi)), sd=sqrt(sigma2), mean=alpha)
estimator(y, 3)
estimator(y, 6)
y = arima.sim(n = 1000, list(ar=c(phi)), sd=sqrt(sigma2), mean=alpha)
estimator(y, 3)
estimator(y, 6)
y = arima.sim(n = 1000, list(ar=c(phi)), sd=sqrt(sigma2), mean=alpha)
estimator(y, 1)
estimator(y, 6)
y = arima.sim(n = 1000, list(ar=c(phi)), sd=sqrt(sigma2), mean=alpha)
estimator(y, 1)
estimator(y, 6)
y = arima.sim(n = 1000, list(ar=c(phi)), sd=sqrt(sigma2), mean=alpha)
estimator(y, 1)
estimator(y, 6)
y = arima.sim(n = 1000, list(ar=c(phi)), sd=sqrt(sigma2), mean=alpha)
estimator(y, 1)
estimator(y, 6)
y = arima.sim(n = 1000, list(ar=c(phi)), sd=sqrt(sigma2), mean=alpha)
estimator(y, 1)
estimator(y, 6)
y = arima.sim(n = 1000, list(ar=c(phi)), sd=sqrt(sigma2), mean=alpha)
estimator(y, 1)
estimator(y, 6)
head(loss)
head(a)
head(rev(y))
row_number = length(y) - modelling_params + 1
vec = matrix(rev(y)[1 : modelling_params+1], ncol = modelling_params)
vec
rev(y)[1]
rev(y)[0]
rev(y)
modelling_params
rev(y)[1 : modelling_params+1]
rev(y)
head(rev(y))
rev(y)[1]
head(rev(y))
rev(y)[1 : modelling_params+1]
vec = matrix(rev(y)[1 : modelling_params + 1], ncol = modelling_params)
i =2
i = 3
vec = rbind(vec, matrix(rev(y)[i : (i + modelling_params - 1)], ncol=modelling_params))
vec
k = 1
y = arima.sim(n = 1000, list(ar=c(phi)), sd=sqrt(sigma2), mean=alpha)
phi_k = estimator(y, k)[[1]]
x = c(1,rev(y)[2:(k+1)])
y_resid_k = (x %*% phi_k - rev(y)[1])^2
resids = c(resids, y_resid_k)
resids
resids = c()
phi_k = estimator(y, k)[[1]]
x = c(1,rev(y)[2:(k+1)])
y_resid_k = (x %*% phi_k - rev(y)[1])^2
resids = c(resids, y_resid_k)
resids
k = 2
phi_k = estimator(y, k)[[1]]
x = c(1,rev(y)[2:(k+1)])
y_resid_k = (x %*% phi_k - rev(y)[1])^2
resids = c(resids, y_resid_k)
resids
resids = c()
for (k in i_vec) {
phi_k = estimator(y, k)[[1]]
x = c(1,rev(y)[2:(k+1)])
y_resid_k = (x %*% phi_k - rev(y)[1])^2
resids = c(resids, y_resid_k)
}
resids
y = arima.sim(n = 1000, list(ar=c(phi)), sd=sqrt(sigma2), mean=alpha)
resids = c()
for (k in i_vec) {
phi_k = estimator(y, k)[[1]]
x = c(1,rev(y)[2:(k+1)])
y_resid_k = (x %*% phi_k - rev(y)[1])^2
resids = c(resids, y_resid_k)
}
resids
k = 2
phi_k = estimator(y, k)[[1]]
x = c(1,rev(y)[2:(k+1)])
y_resid_k = (x %*% phi_k - rev(y)[1])^2
y_resid_k
phi_k
estimator(y, k)
estimator(y, 6)
estimator(y, 1)
rev(y)[1]
phi_k
x %*% phi_k
k = 4
phi_k = estimator(y, k)[[1]]
x = c(1,rev(y)[2:(k+1)])
x %*% phi_k
rev(y, 2)
rev(y)[2]
phi_k
k = 2
phi_k = estimator(y, k)[[1]]
x = c(1,rev(y)[2:(k+1)])
y_resid_k = (x %*% phi_k - rev(y)[1])^2
y_resid_k
estimator(y, k)
setwd("C:/Marci/CEU/ThesisDONTUSETHIS/CODE/R")
library(MCS)
library(optimParallel)
path <- function(m,n) {
return(paste0("MN-SEIR-MODELS/m", m, "n", n, ".R"))
}
parscale.parameters <- function(par, scale, fix = 1){
#check if length of scale is equal to par
if(length(par) !=  length(scale)){
stop("parscale.parameters has parameter and scaling vectors of different sizes.")
}
if(any(scale == 0)){
scale[scale == 0] <- 1
}
#parscale fixes the larged par/parscale value to deviate only 10 percent, others can then vary
#get fixed and maximal value
fix.value <- par[fix]
if(fix.value == 0){
fix.value <- 1
}
max.value <- abs(par[which.max(abs(par))[1]])
if(max.value == 0){
print("Warning: Vector contains only zeroes. Scaling is set to a default of 1.")
max.value <- 1
}
#fill in scaling vector
par.scale <- scale/(0.1 * fix.value * max.value)
par.scale[fix] <- 1 / max.value
return(abs(par.scale))
}
parameter_values <- c(
k=50,
b=0.2,
q=0.4,
sigma=1,
gamma=1/5,
d_I=0.5,
tau_d = 2
)
scale=c(20, 0.05, 0.05, 0.1, 0.1, 0.05, 0.1)
p.scale=parscale.parameters(parameter_values, scale)
pars <- vector(mode="list", length=25)
vec = c()
for (m in 1:5) {
for (n in 1:5) {
vec <- c(vec, paste0("m",m,"n",n))
}
}
names(pars) <- vec
source(path(m,n))
m
m=3
n=4
n=3
m
n
source(path(m,n))
initial_params = parameter_values
cl <- makeCluster(detectCores())
optimum <- optimParallel(par=initial_params,
fn=mn_optim,
lower=rep(0, 7),
upper = c(Inf, 1, 1, Inf, Inf, 1, Inf),
control=list(maxit=150, trace=T, fnscale=25000000, parscale=p.scale),
parallel=list(cl=cl))
optimum
mn_optim <- function(parameter_values) {
factorial <- function(n, acc=1) {
if (n <= 0) {
return(acc)
} else {
return(factorial(n-1, acc * n))
}
}
P.gen <- function(m, sigma, E_m_lagged, tau_d, n, gamma, i) {
return(m * sigma * E_m_lagged * exp(-n*gamma*tau_d)*((n*gamma*tau_d)^(i-1))/factorial(i-1))
}
mn_seir_equations <- function(time, variables, parameters) {
with(as.list(c(variables, parameters)), {
if (time <= tau_q+1){
lagged = rep(0, 2)} #this is for S(t-tau_q) and I_S(t-tauq)
else {
lagged = deSolve :: lagvalue(time - tau_q)[c(1, 2)]
}
dS <- -(k*b*I+q*k*(1-b)*I_S)*S/N + (q*k*(1-b) * lagged[1] * lagged[2] )/N
dS_Q <- (q*k*(1-b)*S*I_S)/N - (q*k*(1-b) * lagged[1] * lagged[2] )/N
dE1 <- (k*b*(I - q*I_S))*S/N - m*sigma*E1
dE2 <- m * sigma * (E1 - E2)
dE3 <- m * sigma * (E2 - E3)
if (time <= tau_d+1){
lagged1 = rep(0,2)} #this is for E_m(t-tau_d)
else {
lagged1 = deSolve :: lagvalue(time - tau_d)[c(6,7)]
}
dP_I1 = P.gen(m, sigma, m * sigma * (lagged1[1] - lagged1[2]), tau_d, n, gamma, 1)
dP_I2 = P.gen(m, sigma, m * sigma * (lagged1[1] - lagged1[2]), tau_d, n, gamma, 2)
dP_I3 = P.gen(m, sigma, m * sigma * (lagged1[1] - lagged1[2]), tau_d, n, gamma, 3)
dI_A1 = m*sigma*E3 - n*gamma*I_A1 - P_I1
dI_A2 <- n*gamma* I_A1 - n*gamma*I_A2 - P_I2
dI_A3 <- n*gamma* I_A2 - n*gamma*I_A3 - P_I3
dI_A <- dI_A1 + dI_A2 + dI_A3
dI_S1 <- P_I1 - (n*gamma + d_I) * I_S1
dI_S2 <- P_I2 + n * gamma * I_S1 - (n*gamma+d_I) * I_S2
dI_S3 <- P_I3 + n * gamma * I_S2 - (n*gamma+d_I) * I_S3
dI_S <- dI_S1+dI_S2+dI_S3
dI = dI_A + dI_S
dQ <- (q*k*b*S*I_S)/N + d_I*I_S
dR <- n*gamma*(I_A3 + I_S3)
return(list(c(dS, dI_S, dI, dS_Q, dE1, dE2, dE3, dI_A1,dI_A2,dI_A3, dI_S1,dI_S2,dI_S3, dI_A, dP_I1, dP_I2, dP_I3, dQ, dR)))
})
}
initial_values <- c(
S=19449999,
I_S = 1,
I=1,
S_Q=0,
E1 = 0,
E2 = 0,
E3=0,
I_A1 = 0,
I_A2 = 0,
I_A3 = 0,
I_S1 = 1,
I_S2 = 0,
I_S3 = 0,
I_A =0,
P_I1 = 0.0,
P_I2 = 0.0,
P_I3 = 0.0,
Q=0,
R=0
)
cases=read.csv("curve.csv")$x
cases=head(cases, length(cases) * 0.75)
out = deSolve :: dede(
y=initial_values,
times=1:length(cases),
func=mn_seir_equations,
parms = c(parameter_values, N=19450000, m=3, n=3, tau_q=14),
method = "impAdams",
control=list(interpol=2)
)
out = as.data.frame(out)
return(sum((out$I_s + out$Q +out$R - cases)^2) / length(cases))
}
mn_optim(optimum$par)
mn_optim <- function(parameter_values) {
factorial <- function(n, acc=1) {
if (n <= 0) {
return(acc)
} else {
return(factorial(n-1, acc * n))
}
}
P.gen <- function(m, sigma, E_m_lagged, tau_d, n, gamma, i) {
return(m * sigma * E_m_lagged * exp(-n*gamma*tau_d)*((n*gamma*tau_d)^(i-1))/factorial(i-1))
}
mn_seir_equations <- function(time, variables, parameters) {
with(as.list(c(variables, parameters)), {
if (time <= tau_q+1){
lagged = rep(0, 2)} #this is for S(t-tau_q) and I_S(t-tauq)
else {
lagged = deSolve :: lagvalue(time - tau_q)[c(1, 2)]
}
dS <- -(k*b*I+q*k*(1-b)*I_S)*S/N + (q*k*(1-b) * lagged[1] * lagged[2] )/N
dS_Q <- (q*k*(1-b)*S*I_S)/N - (q*k*(1-b) * lagged[1] * lagged[2] )/N
dE1 <- (k*b*(I - q*I_S))*S/N - m*sigma*E1
dE2 <- m * sigma * (E1 - E2)
dE3 <- m * sigma * (E2 - E3)
if (time <= tau_d+1){
lagged1 = rep(0,2)} #this is for E_m(t-tau_d)
else {
lagged1 = deSolve :: lagvalue(time - tau_d)[c(6,7)]
}
dP_I1 = P.gen(m, sigma, m * sigma * (lagged1[1] - lagged1[2]), tau_d, n, gamma, 1)
dP_I2 = P.gen(m, sigma, m * sigma * (lagged1[1] - lagged1[2]), tau_d, n, gamma, 2)
dP_I3 = P.gen(m, sigma, m * sigma * (lagged1[1] - lagged1[2]), tau_d, n, gamma, 3)
dI_A1 = m*sigma*E3 - n*gamma*I_A1 - P_I1
dI_A2 <- n*gamma* I_A1 - n*gamma*I_A2 - P_I2
dI_A3 <- n*gamma* I_A2 - n*gamma*I_A3 - P_I3
dI_A <- dI_A1 + dI_A2 + dI_A3
dI_S1 <- P_I1 - (n*gamma + d_I) * I_S1
dI_S2 <- P_I2 + n * gamma * I_S1 - (n*gamma+d_I) * I_S2
dI_S3 <- P_I3 + n * gamma * I_S2 - (n*gamma+d_I) * I_S3
dI_S <- dI_S1+dI_S2+dI_S3
dI = dI_A + dI_S
dQ <- (q*k*b*S*I_S)/N + d_I*I_S
dR <- n*gamma*(I_A3 + I_S3)
return(list(c(dS, dI_S, dI, dS_Q, dE1, dE2, dE3, dI_A1,dI_A2,dI_A3, dI_S1,dI_S2,dI_S3, dI_A, dP_I1, dP_I2, dP_I3, dQ, dR)))
})
}
initial_values <- c(
S=19449999,
I_S = 1,
I=1,
S_Q=0,
E1 = 0,
E2 = 0,
E3=0,
I_A1 = 0,
I_A2 = 0,
I_A3 = 0,
I_S1 = 1,
I_S2 = 0,
I_S3 = 0,
I_A =0,
P_I1 = 0.0,
P_I2 = 0.0,
P_I3 = 0.0,
Q=0,
R=0
)
cases=read.csv("curve.csv")$x
cases=head(cases, length(cases) * 0.75)
out = deSolve :: dede(
y=initial_values,
times=1:length(cases),
func=mn_seir_equations,
parms = c(parameter_values, N=19450000, m=3, n=3, tau_q=14),
method = "impAdams",
control=list(interpol=2)
)
out = as.data.frame(out)
return(out)
return(sum((out$I_s + out$Q +out$R - cases)^2) / length(cases))
}
mn_optim(optimum$par)
a = mn_optim(optimum$par)
cases=read.csv("curve.csv")$x
cases=head(cases, length(cases) * 0.75)
plot(cases)
plot(a$I_S)
plot(a$Q)
plot(a$R)
plot(a$R+a$I_S+a$Q)
plot(a$R+a$I_S+a$Q)
a$R+a$I_S+a$Q - cases
(a$R+a$I_S+a$Q - cases)^2
sum((a$R+a$I_S+a$Q - cases)^2)
sum((a$R+a$I_S+a$Q - cases)^2)/length(cases)
out=a
out
sum((out$I_s + out$Q +out$R - cases)^2) / length(cases)
sum((out$I_s + out$Q +out$R - cases)^2)
cases
out$I_s + out$Q +out$R - cases
out$I_s + out$Q +out$R
out$I_s
out
stopCluster(cl)
m
n
source(path(m,n))
initial_params = parameter_values
cl <- makeCluster(detectCores())
optimum <- optimParallel(par=initial_params,
fn=mn_optim,
lower=rep(0, 7),
upper = c(Inf, 1, 1, Inf, Inf, 1, Inf),
control=list(maxit=150, trace=T, fnscale=25000000, parscale=p.scale),
parallel=list(cl=cl))
optimum
mn_optim <- function(parameter_values) {
factorial <- function(n, acc=1) {
if (n <= 0) {
return(acc)
} else {
return(factorial(n-1, acc * n))
}
}
P.gen <- function(m, sigma, E_m_lagged, tau_d, n, gamma, i) {
return(m * sigma * E_m_lagged * exp(-n*gamma*tau_d)*((n*gamma*tau_d)^(i-1))/factorial(i-1))
}
mn_seir_equations <- function(time, variables, parameters) {
with(as.list(c(variables, parameters)), {
if (time <= tau_q+1){
lagged = rep(0, 2)} #this is for S(t-tau_q) and I_S(t-tauq)
else {
lagged = deSolve :: lagvalue(time - tau_q)[c(1, 2)]
}
dS <- -(k*b*I+q*k*(1-b)*I_S)*S/N + (q*k*(1-b) * lagged[1] * lagged[2] )/N
dS_Q <- (q*k*(1-b)*S*I_S)/N - (q*k*(1-b) * lagged[1] * lagged[2] )/N
dE1 <- (k*b*(I - q*I_S))*S/N - m*sigma*E1
dE2 <- m * sigma * (E1 - E2)
dE3 <- m * sigma * (E2 - E3)
if (time <= tau_d+1){
lagged1 = rep(0,2)} #this is for E_m(t-tau_d)
else {
lagged1 = deSolve :: lagvalue(time - tau_d)[c(6,7)]
}
dP_I1 = P.gen(m, sigma, m * sigma * (lagged1[1] - lagged1[2]), tau_d, n, gamma, 1)
dP_I2 = P.gen(m, sigma, m * sigma * (lagged1[1] - lagged1[2]), tau_d, n, gamma, 2)
dP_I3 = P.gen(m, sigma, m * sigma * (lagged1[1] - lagged1[2]), tau_d, n, gamma, 3)
dI_A1 = m*sigma*E3 - n*gamma*I_A1 - P_I1
dI_A2 <- n*gamma* I_A1 - n*gamma*I_A2 - P_I2
dI_A3 <- n*gamma* I_A2 - n*gamma*I_A3 - P_I3
dI_A <- dI_A1 + dI_A2 + dI_A3
dI_S1 <- P_I1 - (n*gamma + d_I) * I_S1
dI_S2 <- P_I2 + n * gamma * I_S1 - (n*gamma+d_I) * I_S2
dI_S3 <- P_I3 + n * gamma * I_S2 - (n*gamma+d_I) * I_S3
dI_S <- dI_S1+dI_S2+dI_S3
dI = dI_A + dI_S
dQ <- (q*k*b*S*I_S)/N + d_I*I_S
dR <- n*gamma*(I_A3 + I_S3)
return(list(c(dS, dI_S, dI, dS_Q, dE1, dE2, dE3, dI_A1,dI_A2,dI_A3, dI_S1,dI_S2,dI_S3, dI_A, dP_I1, dP_I2, dP_I3, dQ, dR)))
})
}
initial_values <- c(
S=19449999,
I_S = 1,
I=1,
S_Q=0,
E1 = 0,
E2 = 0,
E3=0,
I_A1 = 0,
I_A2 = 0,
I_A3 = 0,
I_S1 = 1,
I_S2 = 0,
I_S3 = 0,
I_A =0,
P_I1 = 0.0,
P_I2 = 0.0,
P_I3 = 0.0,
Q=0,
R=0
)
cases=read.csv("curve.csv")$x
cases=head(cases, length(cases) * 0.75)
out = deSolve :: dede(
y=initial_values,
times=1:length(cases),
func=mn_seir_equations,
parms = c(parameter_values, N=19450000, m=3, n=3, tau_q=14),
method = "impAdams",
control=list(interpol=2)
)
out = as.data.frame(out)
return(out)
return(sum((out$I_S + out$Q +out$R - cases)^2) / length(cases))
}
a=mn_optim(optimum$par)
plot(a$I_S)
plot(a$Q)
plot(a$R)
plot(a$I_S + a$Q + a$R)
plot(cases)
optimum <- optimParallel(par=initial_params,
fn=mn_optim,
lower=rep(0, 7),
upper = c(Inf, 1, 1, Inf, Inf, 1, Inf),
control=list(maxit=150, trace=6, fnscale=25000000, parscale=p.scale),
parallel=list(cl=cl))
