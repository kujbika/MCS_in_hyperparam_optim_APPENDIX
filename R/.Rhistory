grid_search <- function(alpha, phi, sigma2, i_vec) {
y = arima.sim(n = 1000, list(ar=c(phi)), sd=sqrt(sigma2), mean=alpha)
resids = resid_generator(y, i_vec)
phi_i = estimator(y, which.min(resids))
prediction = c(1, rev(y)[1:(length(phi_i[[1]])-1)]) %*% phi_i[[1]]
real = c(1, rev(y)[1:length(phi)]) %*% c(alpha, phi)
return ((prediction - real)^2)
}
grid_search(alpha, phi, sigma2, 1:8)
y = arima.sim(n = 1000, list(ar=c(phi)), sd=sqrt(sigma2), mean=alpha)
resids = resid_generator(y, i_vec)
resids
which.min(resids)
phi_i = estimator(y, which.min(resids))
phi_i
prediction = c(1, rev(y)[1:(length(phi_i[[1]])-1)]) %*% phi_i[[1]]
real = c(1, rev(y)[1:length(phi)]) %*% c(alpha, phi)
real = c(1, rev(y)[1:length(phi)]) %*% c(alpha, phi) + rnorm(1, 0, sigma2)
prediction
real
((prediction - real)^2)
grid_search <- function(alpha, phi, sigma2, i_vec) {
y = arima.sim(n = 1000, list(ar=c(phi)), sd=sqrt(sigma2), mean=alpha)
resids = resid_generator(y, i_vec)
phi_i = estimator(y, which.min(resids))
prediction = c(1, rev(y)[1:(length(phi_i[[1]])-1)]) %*% phi_i[[1]]
real = c(1, rev(y)[1:length(phi)]) %*% c(alpha, phi) + rnorm(1, 0, sigma2)
return ((prediction - real)^2)
}
grid_search <- function(alpha, phi, sigma2, i_vec) {
y = arima.sim(n = 2000, list(ar=c(phi)), sd=sqrt(sigma2), mean=alpha)
resids = resid_generator(y, i_vec)
phi_i = estimator(y, which.min(resids))
prediction = c(1, rev(y)[1:(length(phi_i[[1]])-1)]) %*% phi_i[[1]]
real = c(1, rev(y)[1:length(phi)]) %*% c(alpha, phi) + rnorm(1, 0, sigma2)
return ((prediction - real)^2)
}
b = c()
for (i in 1:1000) {
b = c(b, grid_search(alpha, phi, sigma2, 1:8))
}
hist(b)
b
grid_search <- function(alpha, phi, sigma2, i_vec) {
y = arima.sim(n = 2000, list(ar=c(phi)), sd=sqrt(sigma2), mean=alpha)
resids = resid_generator(y, i_vec)
phi_i = estimator(y, which.min(resids))
prediction = c(1, rev(y)[1:(length(phi_i[[1]])-1)]) %*% phi_i[[1]]
real = c(1, rev(y)[1:length(phi)]) %*% c(alpha, phi) + rnorm(1, 0, sigma2)
return ((prediction - real)^2)
}
b = c()
for (i in 1:1000) {
b = c(b, grid_search(alpha, phi, sigma2, 1:8))
}
hist(b)
mean(b)
cor(a)
#-------------------------------------------------------------
resid_generator <- function(y, i_vec) {
resids = c()
for (k in i_vec) {
phi_k = estimator(y, k)[[1]]
x = c(1,rev(y)[2:(k+1)])
y_resid_k = (x %*% phi_k - rev(y)[1])^2
resids = c(resids, y_resid_k)
}
return (resids) }
loss_values <- function(alpha, phi, sigma2) {
loss = data.frame("loss_1" = NA,
"loss_2" = NA,
"loss_3" = NA,
"loss_4" = NA,
"loss_5" = NA,
"loss_6" = NA,
"loss_7" = NA,
"loss_8" = NA,
"min_index" = NA)
for (k in 1:2000)
{
y = arima.sim(n = 1000, list(ar=c(phi)), sd=sqrt(sigma2), mean=alpha)
resids = resid_generator(y, 1:8)
loss = rbind(loss, c(resids, which.min(resids)))
}
return (loss[-1,])
}
alpha <- 5
phi <-  c(0.8, .25, -0.4, 0.1) # phi_1, phi_2, phi_3. order matters!
phi = isStationer(phi)
sigma2 <- 1.2
a = loss_values(alpha, phi, sigma2)
cor(a)
summary(a)
hist(a$min_index)
y = arima.sim(n = 1000, list(ar=c(phi)), sd=sqrt(sigma2), mean=alpha)
estimator(y, 3)
phi
alpha
y = arima.sim(n = 1000, list(ar=c(phi)), sd=sqrt(sigma2), mean=alpha)
y = arima.sim(n = 1000, list(ar=c(phi)), sd=sqrt(sigma2), mean=alpha)
estimator(y, 3)
estimator(y, 6)
y = arima.sim(n = 1000, list(ar=c(phi)), sd=sqrt(sigma2), mean=alpha)
estimator(y, 3)
estimator(y, 6)
y = arima.sim(n = 1000, list(ar=c(phi)), sd=sqrt(sigma2), mean=alpha)
estimator(y, 3)
estimator(y, 6)
y = arima.sim(n = 1000, list(ar=c(phi)), sd=sqrt(sigma2), mean=alpha)
estimator(y, 3)
estimator(y, 6)
y = arima.sim(n = 1000, list(ar=c(phi)), sd=sqrt(sigma2), mean=alpha)
estimator(y, 3)
estimator(y, 6)
y = arima.sim(n = 1000, list(ar=c(phi)), sd=sqrt(sigma2), mean=alpha)
estimator(y, 3)
estimator(y, 6)
y = arima.sim(n = 1000, list(ar=c(phi)), sd=sqrt(sigma2), mean=alpha)
estimator(y, 3)
estimator(y, 6)
y = arima.sim(n = 1000, list(ar=c(phi)), sd=sqrt(sigma2), mean=alpha)
estimator(y, 3)
estimator(y, 6)
y = arima.sim(n = 1000, list(ar=c(phi)), sd=sqrt(sigma2), mean=alpha)
estimator(y, 3)
estimator(y, 6)
y = arima.sim(n = 1000, list(ar=c(phi)), sd=sqrt(sigma2), mean=alpha)
estimator(y, 3)
estimator(y, 6)
y = arima.sim(n = 1000, list(ar=c(phi)), sd=sqrt(sigma2), mean=alpha)
estimator(y, 3)
estimator(y, 6)
y = arima.sim(n = 1000, list(ar=c(phi)), sd=sqrt(sigma2), mean=alpha)
estimator(y, 3)
estimator(y, 6)
y = arima.sim(n = 1000, list(ar=c(phi)), sd=sqrt(sigma2), mean=alpha)
estimator(y, 3)
estimator(y, 6)
y = arima.sim(n = 1000, list(ar=c(phi)), sd=sqrt(sigma2), mean=alpha)
estimator(y, 3)
estimator(y, 6)
y = arima.sim(n = 1000, list(ar=c(phi)), sd=sqrt(sigma2), mean=alpha)
estimator(y, 3)
estimator(y, 6)
y = arima.sim(n = 1000, list(ar=c(phi)), sd=sqrt(sigma2), mean=alpha)
estimator(y, 3)
estimator(y, 6)
y = arima.sim(n = 1000, list(ar=c(phi)), sd=sqrt(sigma2), mean=alpha)
estimator(y, 3)
estimator(y, 6)
y = arima.sim(n = 1000, list(ar=c(phi)), sd=sqrt(sigma2), mean=alpha)
estimator(y, 3)
estimator(y, 6)
y = arima.sim(n = 1000, list(ar=c(phi)), sd=sqrt(sigma2), mean=alpha)
estimator(y, 3)
estimator(y, 6)
y = arima.sim(n = 1000, list(ar=c(phi)), sd=sqrt(sigma2), mean=alpha)
estimator(y, 3)
estimator(y, 6)
y = arima.sim(n = 1000, list(ar=c(phi)), sd=sqrt(sigma2), mean=alpha)
estimator(y, 1)
estimator(y, 6)
y = arima.sim(n = 1000, list(ar=c(phi)), sd=sqrt(sigma2), mean=alpha)
estimator(y, 1)
estimator(y, 6)
y = arima.sim(n = 1000, list(ar=c(phi)), sd=sqrt(sigma2), mean=alpha)
estimator(y, 1)
estimator(y, 6)
y = arima.sim(n = 1000, list(ar=c(phi)), sd=sqrt(sigma2), mean=alpha)
estimator(y, 1)
estimator(y, 6)
y = arima.sim(n = 1000, list(ar=c(phi)), sd=sqrt(sigma2), mean=alpha)
estimator(y, 1)
estimator(y, 6)
y = arima.sim(n = 1000, list(ar=c(phi)), sd=sqrt(sigma2), mean=alpha)
estimator(y, 1)
estimator(y, 6)
head(loss)
head(a)
head(rev(y))
row_number = length(y) - modelling_params + 1
vec = matrix(rev(y)[1 : modelling_params+1], ncol = modelling_params)
vec
rev(y)[1]
rev(y)[0]
rev(y)
modelling_params
rev(y)[1 : modelling_params+1]
rev(y)
head(rev(y))
rev(y)[1]
head(rev(y))
rev(y)[1 : modelling_params+1]
vec = matrix(rev(y)[1 : modelling_params + 1], ncol = modelling_params)
i =2
i = 3
vec = rbind(vec, matrix(rev(y)[i : (i + modelling_params - 1)], ncol=modelling_params))
vec
k = 1
y = arima.sim(n = 1000, list(ar=c(phi)), sd=sqrt(sigma2), mean=alpha)
phi_k = estimator(y, k)[[1]]
x = c(1,rev(y)[2:(k+1)])
y_resid_k = (x %*% phi_k - rev(y)[1])^2
resids = c(resids, y_resid_k)
resids
resids = c()
phi_k = estimator(y, k)[[1]]
x = c(1,rev(y)[2:(k+1)])
y_resid_k = (x %*% phi_k - rev(y)[1])^2
resids = c(resids, y_resid_k)
resids
k = 2
phi_k = estimator(y, k)[[1]]
x = c(1,rev(y)[2:(k+1)])
y_resid_k = (x %*% phi_k - rev(y)[1])^2
resids = c(resids, y_resid_k)
resids
resids = c()
for (k in i_vec) {
phi_k = estimator(y, k)[[1]]
x = c(1,rev(y)[2:(k+1)])
y_resid_k = (x %*% phi_k - rev(y)[1])^2
resids = c(resids, y_resid_k)
}
resids
y = arima.sim(n = 1000, list(ar=c(phi)), sd=sqrt(sigma2), mean=alpha)
resids = c()
for (k in i_vec) {
phi_k = estimator(y, k)[[1]]
x = c(1,rev(y)[2:(k+1)])
y_resid_k = (x %*% phi_k - rev(y)[1])^2
resids = c(resids, y_resid_k)
}
resids
k = 2
phi_k = estimator(y, k)[[1]]
x = c(1,rev(y)[2:(k+1)])
y_resid_k = (x %*% phi_k - rev(y)[1])^2
y_resid_k
phi_k
estimator(y, k)
estimator(y, 6)
estimator(y, 1)
rev(y)[1]
phi_k
x %*% phi_k
k = 4
phi_k = estimator(y, k)[[1]]
x = c(1,rev(y)[2:(k+1)])
x %*% phi_k
rev(y, 2)
rev(y)[2]
phi_k
k = 2
phi_k = estimator(y, k)[[1]]
x = c(1,rev(y)[2:(k+1)])
y_resid_k = (x %*% phi_k - rev(y)[1])^2
y_resid_k
estimator(y, k)
setwd("C:/Marci/CEU/ThesisDONTUSETHIS/CODE/R")
load("covidePred2.RData")
Loss
sqrt(apply(Loss, 2, sum)/nrow(Loss))
MCS
?MCSprocedure
get_parameter(MCS)
MCS
Loss
sqrt(apply(Loss, 2, sum)/nrow(Loss))
####grid search chooses m3n1
params <- coeffs[[11]]
params
pars
pars[[11]]
sum(pars[[1]])/11
sqrt(sum(pars[[1]])/11)
sqrt(apply(Loss, 2, sum)/nrow(Loss))
sum(pars[[11]])/length(pars[[11]])
sqrt(sum(pars[[11]])/length(pars[[11]]))
####grid search chooses m3n1
params <- coeffs[[11]]
params
mn_optim <- function(parameter_values) {
factorial <- function(n, acc=1) {
if (n <= 0) {
return(acc)
} else {
return(factorial(n-1, acc * n))
}
}
P.gen <- function(m, sigma, E_m_lagged, tau_d, n, gamma, i) {
return(m * sigma * E_m_lagged * exp(-n*gamma*tau_d)*((n*gamma*tau_d)^(i-1))/factorial(i-1))
}
mn_seir_equations <- function(time, variables, parameters) {
with(as.list(c(variables, parameters)), {
if (time <= tau_q+1){
lagged = rep(0, 2)} #this is for S(t-tau_q) and I_S(t-tauq)
else {
lagged = deSolve :: lagvalue(time - tau_q)[c(1, 2)]
}
dS <- -(K*b*I+q*K*(1-b)*I_S)*S/N + (q*K*(1-b) * lagged[1] * lagged[2] )/N
dS_Q <- (q*K*(1-b)*S*I_S)/N - (q*K*(1-b) * lagged[1] * lagged[2] )/N
dE1 <- (K*b*(I - q*I_S))*S/N - m*sigma*E1
dE2 <- m * sigma * E1 - m * sigma * E2
dE3 <- m * sigma * E2 - m * sigma * E3
if (time <= tau_d+1){
lagged1 = rep(0,2)} #this is for E_m(t-tau_d)
else {
lagged1 = deSolve :: lagvalue(time - tau_d)[c(6,7)]
}
dP_I1 = P.gen(m, sigma, m * sigma * (lagged1[1] - lagged1[2]), tau_d, n, gamma, 1)
dI_A1 = m*sigma*E3 - n*gamma*I_A1 - P_I1
dI_A <- dI_A1
dI_S1 <- P_I1 - (n*gamma + d_I) * I_S1
dI_S <- dI_S1
dI = dI_A + dI_S
dQ <- (q*K*b*S*I_S)/N + d_I*I_S
dR <- n*gamma*(I_A1 + I_S1)
dK <- -(K-min_contract_size)/lambda
return(list(c(dS,dI_S, dI, dS_Q, dE1, dE2, dE3, dI_A1, dI_S1, dI_A, dP_I1, dQ, dR, dK)))
})
}
initial_values <- c(
S=19449999,
I_S = 1,
I=1,
S_Q=0,
E1 = 0,
E2 = 0,
E3=0,
I_A1 = 0,
I_S1 = 1,
I_A =0,
P_I1 = 0.0,
Q=0,
R=0,
K=50
)
cases=read.csv("curve.csv")$x
cases=head(cases, length(cases) * 1)
out = deSolve :: dede(
y=initial_values,
times=1:length(cases),
func=mn_seir_equations,
parms = c(parameter_values, N=19450000, m=3, n=1, tau_q=14),
method = "impAdams",
control = list(interpol=2)
)
out = as.data.frame(out)
return(out)
return(sum((out$I_S + out$Q + out$R - cases)^2) / length(cases))
}
params
a=mn_optim(params)
plot(a$I_S + a$Q + a$R)
cases
cases = read.csv("curve.csv")$x
lines(cases)
plot(a$I_S + a$Q + a$R, type="l")
lines(cases)
plot(a$I_S + a$Q + a$R, type="l", col="blue")
lines(cases)
plot(a$I_S + a$Q + a$R)
lines(cases)
plot_df <- data.frame("model"=a$I_S+a$Q+a$R, "reality"=cases)
library(ggplot2)
install.packages("ggplot2")
library(ggplot2)
plot_df
p <- ggplot(data=plot_df)+geom_line(aes(y=model, colour=model))+geom_line(aes(y=reality, colour=model))
p
plot_df <- data.frame("model"=a$I_S+a$Q+a$R, "reality"=cases,"index"=1:length(cases))
p <- ggplot(data=plot_df, aes(x=index))+geom_line(aes(y=model, colour=model))+geom_line(aes(y=reality, colour=model))
p
p <- ggplot(data=plot_df, aes(x=index))+geom_line(aes(y=model, colour=blue))+geom_line(aes(y=reality, colour=red))
p
p <- ggplot(data=plot_df, aes(x=index))+geom_line(aes(y=model, colour="blue"))+geom_line(aes(y=reality, colour=red))
p
p <- ggplot(data=plot_df, aes(x=index))+geom_line(aes(y=model, colour="blue"))+geom_line(aes(y=reality, colour="red"))
p
p <- ggplot(data=plot_df, aes(x=index))+geom_line(aes(y=model, colour=model))+geom_line(aes(y=reality, colour=reality))
p
p <- ggplot(data=plot_df, aes(x=index))+geom_line(aes(y=model, colour="blue"))+geom_line(aes(y=reality, colour="red"))
p
p <- ggplot(data=plot_df, aes(x=index))+geom_line(aes(y=model))+geom_line(aes(y=reality))
p
p <- ggplot(data=plot_df, aes(x=index))+geom_line(aes(y=model, colour="blue"))+geom_line(aes(y=reality, colour="red"))
p
cases = read.csv("curve.csv")
cases
str(cases)
install.packages("lubridate")
library(lubridate)
cases
cases = read.csv("curve.csv")
cases
cases$Date=ymd(cases$Date)
cases
plot_df <- cbind(cases, "model"=a$I_S+a$Q+a$R)
plot_df
p <- ggplot(data=plot_df, aes(x=Date))+geom_line(aes(y=model, colour="blue"))+geom_line(aes(y=x, colour="red"))
p
p <- ggplot(data=plot_df, aes(x=Date))+
geom_line(aes(y=model, colour="blue"))+
geom_line(aes(y=x, colour="red"))+
scale_x_date(date_labels="%m-%Y")
p
p <- ggplot(data=plot_df, aes(x=Date))+
geom_line(aes(y=model, colour="blue"))+
geom_point(aes(y=x))+
geom_line(aes(y=x, colour="red"))+
scale_x_date(date_labels="%m-%Y")
p
p <- ggplot(data=plot_df, aes(x=Date))+
geom_line(aes(y=model, colour="blue"))+
geom_point(aes(y=x))+
scale_x_date(date_labels="%m-%Y")
p
p <- ggplot(data=plot_df, aes(x=Date))+
geom_line(aes(y=model, colour="best grid search model"))+
geom_point(aes(y=x))+
scale_x_date(date_labels="%m-%Y")
p
install.packages("ggplotly")
install.packages("plotly")
ggplotly(p)
library(plotly)
ggplotly(p)
ggplotly(p)
ggiris <- qplot(Petal.Width, Sepal.Length, data = iris, color = Species)
ggplotly(ggiris)
ggplotly(p, dynamicTicks = T)
p
p <- ggplot(data=plot_df, aes(x=Date))+
geom_line(aes(y=model, colour="best grid search model"))+
geom_point(aes(y=x))+
scale_x_date(date_labels="%m-%Y")+
geom_vline(xintercept = as.numeric(plot_df$Date[44]),
linetype=4, colour="black")
p
p <- ggplot(data=plot_df, aes(x=Date))+
geom_line(aes(y=model, colour="best grid search model"))+
geom_point(aes(y=x))+
scale_x_date(date_labels="%m-%Y")+
geom_vline(xintercept = as.numeric(plot_df$Date[44]),
linetype=4, colour="black")+
geom_hline(yintercept = 2e5, color="darkgreen")
p
p <- ggplot(data=plot_df, aes(x=Date))+
geom_line(aes(y=model, colour="best grid search model"))+
geom_point(aes(y=x))+
scale_x_date(date_labels="%m-%Y")+
geom_vline(xintercept = as.numeric(plot_df$Date[44]),
linetype=4, colour="black")+
geom_segment(aes(x=as.numeric(plot_df$Date[1]),
y=2e5, xend=as.numeric(plot_df$Date[44]),
yend=2e5), color="darkgreen")
p
p <- ggplot(data=plot_df, aes(x=Date))+
geom_line(aes(y=model, colour="best grid search model"))+
geom_point(aes(y=x))+
scale_x_date(date_labels="%m-%Y")+
geom_vline(xintercept = as.numeric(plot_df$Date[44]),
linetype=4, colour="black")+
geom_segment(aes(x=as.numeric(plot_df$Date[1]),
y=2e5, xend=as.numeric(plot_df$Date[44]),
yend=2e5), data=plot_df, color="darkgreen")
p
p <- ggplot(data=plot_df, aes(x=Date))+
geom_line(aes(y=model, colour="best grid search model"))+
geom_point(aes(y=x))+
scale_x_date(date_labels="%m-%Y")+
geom_vline(xintercept = as.numeric(plot_df$Date[44]),
linetype=4, colour="black")+
geom_segment(aes(x=as.numeric(Date[1]),
y=2e5, xend=as.numeric(Date[44]),
yend=2e5), data=plot_df, color="darkgreen")
p
p <- ggplot(data=plot_df, aes(x=Date))+
geom_line(aes(y=model, colour="best grid search model"))+
geom_point(aes(y=x))+
scale_x_date(date_labels="%m-%Y")+
geom_vline(xintercept = as.numeric(plot_df$Date[44]),
linetype=4, colour="black")+
geom_hline(yintercept = 2e5, color="darkgreen")
p
p <- ggplot(data=plot_df, aes(x=Date))+
geom_line(aes(y=model, colour="best grid search model"))+
geom_point(aes(y=x))+
scale_x_date(date_labels="%m-%Y")+
geom_vline(xintercept = as.numeric(plot_df$Date[44]),
linetype=4, colour="black")+
geom_hline(yintercept = 2e5, color="darkgreen")+
geom_segment(aes(x=2020-03-01, y=2e5, xend=2020-04-04, yend=2e5), data=plot_df)
p
for (m in 1:5) {
for (n in 1:5) {
source(path(m,n))
initial_params = parameter_values
cl <- makeCluster(detectCores())
optimum <- optimParallel(par=initial_params,
fn=mn_optim,
lower=rep(0,7),
control=list(maxit=150, trace=6, fnscale=250000000),
parallel=list(cl=cl))
residuals=mn_pred(optimum$par)
pars[[paste0("m",m,"n",n)]] = residuals
print(paste("residuals for m=",m,", n=",n, "is ", residuals))
stopCluster(cl)
}
}
pars
